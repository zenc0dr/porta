{"version":3,"file":"graphology.umd.js","sources":["../src/utils.js","../../../node_modules/events/events.js","../src/errors.js","../src/data.js","../src/attributes/nodes.js","../src/attributes/edges.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nexport function chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\n/**\n * Maps the given iterable using the provided function.\n *\n * @param {Iterable} iterable\n * @param {Function} fn\n * @returns {Iterator}\n */\nexport function map(iterable, fn) {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      const step = iterable.next();\n      if (step.done) return step;\n      return {value: fn(step.value), done: false};\n    }\n  };\n}\n\nexport function emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isPlainObject","value","_typeof","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalIdStartingFromRandomByte","Math","floor","random","chain","iterables","current","_defineProperty","Symbol","iterator","next","step","done","emptyIterator","R","Reflect","ReflectApply","apply","receiver","args","Function","prototype","call","ReflectOwnKeys","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","ProcessEmitWarning","warning","console","warn","NumberIsNaN","Number","isNaN","EventEmitter","init","eventsModule","exports","events","once","_events","undefined","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","set","arg","RangeError","getPrototypeOf","create","setMaxListeners","n","_getMaxListeners","that","getMaxListeners","emit","push","doError","error","er","Error","err","message","context","handler","len","listeners","arrayClone","_addListener","prepend","m","existing","newListener","unshift","warned","w","String","emitter","count","addListener","on","prependListener","onceWrapper","fired","removeListener","wrapFn","_onceWrap","state","wrapped","bind","prependOnceListener","list","position","originalListener","shift","spliceOne","off","removeAllListeners","keys","key","_listeners","unwrap","evlistener","unwrapListeners","rawListeners","listenerCount","eventNames","arr","copy","index","pop","ret","Promise","resolve","reject","errorListener","resolver","slice","eventTargetAgnosticAddListener","addErrorHandlerIfEventEmitter","flags","addEventListener","wrapListener","removeEventListener","GraphError","_Error","_inheritsLoose","_this","_wrapNativeSuper","InvalidArgumentsGraphError","_GraphError","_this2","captureStackTrace","_assertThisInitialized","constructor","NotFoundGraphError","_GraphError2","_this3","UsageGraphError","_GraphError3","_this4","MixedNodeData","clear","inDegree","outDegree","undirectedDegree","undirectedLoops","directedLoops","DirectedNodeData","UndirectedNodeData","EdgeData","attach","outKey","inKey","attachMulti","adj","head","previous","detach","detachMulti","NODE","SOURCE","TARGET","OPPOSITE","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","edgeData","arg1","arg2","_edges","attachNodeAttributeGetter","Class","_findRelevantNodeData","data","attachNodeAttributesGetter","_findRelevantNodeData2","attachNodeAttributeChecker","_findRelevantNodeData3","hasOwnProperty","attachNodeAttributeSetter","_findRelevantNodeData4","attachNodeAttributeUpdater","_findRelevantNodeData5","updater","attachNodeAttributeRemover","_findRelevantNodeData6","attachNodeAttributesReplacer","_findRelevantNodeData7","attachNodeAttributesMerger","_findRelevantNodeData8","attachNodeAttributesUpdater","_findRelevantNodeData9","NODE_ATTRIBUTES_METHODS","element","attacher","attachNodeAttributesMethods","Graph","forEach","_ref","attachEdgeAttributeGetter","multi","attachEdgeAttributesGetter","attachEdgeAttributeChecker","attachEdgeAttributeSetter","attachEdgeAttributeUpdater","attachEdgeAttributeRemover","attachEdgeAttributesReplacer","attachEdgeAttributesMerger","attachEdgeAttributesUpdater","EDGE_ATTRIBUTES_METHODS","attachEdgeAttributesMethods","EDGES_ITERATION","direction","forEachSimple","breakable","object","callback","avoid","shouldBreak","forEachMulti","createIterator","sourceAttributes","targetAttributes","forEachForKeySimple","targetData","forEachForKeyMulti","createIteratorForKey","createEdgeArray","size","from","undirectedSize","directedSize","mask","values","forEachEdge","shouldFilter","_data","createEdgeIterator","forEachEdgeForNode","fn","found","createEdgeArrayForNode","edges","createEdgeIteratorForNode","forEachEdgeForPath","createEdgeArrayForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","mapName","result","e","ea","s","t","sa","ta","u","filterName","reduceName","initialValue","accumulator","attachFindEdge","findEdgeName","someName","everyName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","CompositeSetWrapper","A","B","wrap","forEachInObjectOnce","visited","neighborData","forEachNeighbor","createNeighborArrayForNode","neighbors","createDedupedObjectIterator","neighbor","createNeighborIterator","attachNeighborArrayCreator","node","attachForEachNeighbor","a","attachFindNeighbor","capitalizedSingular","findName","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacency","assymetric","disconnectedNodes","hasEdges","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","TYPES","Set","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","isSelfLoop","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","dropEdgeFromData","_EventEmitter","options","instancePrefix","edgeId","edgeKeyGenerator","availableEdgeKey","Map","prop","_options","_proto","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","degree","outboundDegree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","loops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","mergeNode","updateNode","dropNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","_export","_import","merge","_sa","_ta","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addUndirectedEdgeWithKey","addDirectedEdgeWithKey","_node","undirectedByDefault","_edge","_edge$undirected","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","toJSON","toString","inspect","multiIndex","label","tmp","desc","startsWith","dummy","DirectedGraph","_Graph","finalOptions","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","instance"],"mappings":"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"}