{"version":3,"file":"graphology.cjs.js","sources":["../src/utils.js","../src/errors.js","../src/data.js","../src/attributes/nodes.js","../src/attributes/edges.js","../src/iteration/edges.js","../src/iteration/neighbors.js","../src/iteration/adjacency.js","../src/serialization.js","../src/graph.js","../src/classes.js","../src/endpoint.cjs.js"],"sourcesContent":["/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\nexport {assign};\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nexport function isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nexport function validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nexport function chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\n/**\n * Maps the given iterable using the provided function.\n *\n * @param {Iterable} iterable\n * @param {Function} fn\n * @returns {Iterator}\n */\nexport function map(iterable, fn) {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      const step = iterable.next();\n      if (step.done) return step;\n      return {value: fn(step.value), done: false};\n    }\n  };\n}\n\nexport function emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n","/**\n * Graphology Node Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n","/**\n * Graphology Edge Attributes methods\n * ===================================\n */\nimport {assign, isPlainObject, getMatchingEdge} from '../utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from '../errors';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport default function attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {InvalidArgumentsGraphError, NotFoundGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport {chain, emptyIterator} from '../utils';\n\nimport {NotFoundGraphError, InvalidArgumentsGraphError} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport default function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nexport function forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\nimport {InvalidArgumentsGraphError} from './errors';\nimport {assign, isPlainObject, isEmpty} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  EdgeData\n} from './data';\n\nimport attachNodeAttributesMethods from './attributes/nodes';\nimport attachEdgeAttributesMethods from './attributes/edges';\nimport attachEdgeIterationMethods from './iteration/edges';\nimport attachNeighborIterationMethods from './iteration/neighbors';\nimport {forEachAdjacency} from './iteration/adjacency';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isPlainObject,\n  privateProperty,\n  readOnlyProperty,\n  incrementalIdStartingFromRandomByte,\n  validateHints\n} from './utils';\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","/**\n * Graphology CommonJS Endoint\n * ============================\n *\n * Endpoint for CommonJS modules consumers.\n */\nimport {Graph} from './classes';\n\nexport default Graph;\n"],"names":["assignPolyfill","target","arguments","i","l","length","k","assign","Object","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isPlainObject","value","_typeof","isEmpty","o","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","validateHints","hints","attributes","Array","isArray","incrementalIdStartingFromRandomByte","Math","floor","random","chain","iterables","current","_defineProperty","Symbol","iterator","next","step","done","emptyIterator","GraphError","_Error","_inheritsLoose","message","_this","call","_wrapNativeSuper","Error","InvalidArgumentsGraphError","_GraphError","_this2","captureStackTrace","_assertThisInitialized","prototype","constructor","NotFoundGraphError","_GraphError2","_this3","UsageGraphError","_GraphError3","_this4","MixedNodeData","key","clear","inDegree","outDegree","undirectedDegree","undirectedLoops","directedLoops","DirectedNodeData","UndirectedNodeData","EdgeData","attach","outKey","inKey","attachMulti","adj","head","previous","detach","detachMulti","undefined","NODE","SOURCE","TARGET","OPPOSITE","findRelevantNodeData","method","mode","nodeOrEdge","nameOrEdge","add1","add2","nodeData","edgeData","arg1","arg2","concat","_edges","attachNodeAttributeGetter","Class","_findRelevantNodeData","data","attachNodeAttributesGetter","_findRelevantNodeData2","attachNodeAttributeChecker","_findRelevantNodeData3","hasOwnProperty","attachNodeAttributeSetter","_findRelevantNodeData4","emit","attachNodeAttributeUpdater","_findRelevantNodeData5","updater","attachNodeAttributeRemover","_findRelevantNodeData6","attachNodeAttributesReplacer","_findRelevantNodeData7","attachNodeAttributesMerger","_findRelevantNodeData8","attachNodeAttributesUpdater","_findRelevantNodeData9","NODE_ATTRIBUTES_METHODS","element","attacher","attachNodeAttributesMethods","Graph","forEach","_ref","attachEdgeAttributeGetter","multi","attachEdgeAttributesGetter","attachEdgeAttributeChecker","attachEdgeAttributeSetter","attachEdgeAttributeUpdater","attachEdgeAttributeRemover","attachEdgeAttributesReplacer","attachEdgeAttributesMerger","attachEdgeAttributesUpdater","EDGE_ATTRIBUTES_METHODS","attachEdgeAttributesMethods","EDGES_ITERATION","direction","forEachSimple","breakable","object","callback","avoid","shouldBreak","forEachMulti","createIterator","keys","sourceAttributes","targetAttributes","forEachForKeySimple","targetData","forEachForKeyMulti","createIteratorForKey","createEdgeArray","size","from","undirectedSize","directedSize","list","mask","values","forEachEdge","shouldFilter","_data","createEdgeIterator","forEachEdgeForNode","fn","found","createEdgeArrayForNode","edges","push","createEdgeIteratorForNode","forEachEdgeForPath","createEdgeArrayForPath","createEdgeIteratorForPath","attachEdgeArrayCreator","description","has","attachForEachEdge","forEachName","toUpperCase","slice","mapName","args","pop","result","e","ea","s","t","sa","ta","u","apply","filterName","reduceName","initialValue","accumulator","attachFindEdge","findEdgeName","someName","everyName","attachEdgeIteratorCreator","originalName","attachEdgeIterationMethods","NEIGHBORS_ITERATION","CompositeSetWrapper","A","B","wrap","set","forEachInObjectOnce","visited","neighborData","forEachNeighbor","createNeighborArrayForNode","neighbors","createDedupedObjectIterator","neighbor","createNeighborIterator","attachNeighborArrayCreator","node","attachForEachNeighbor","n","a","attachFindNeighbor","capitalizedSingular","findName","attachNeighborIteratorCreator","iteratorName","attachNeighborIterationMethods","forEachAdjacency","assymetric","disconnectedNodes","hasEdges","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","INSTANCE_ID","TYPES","Set","EMITTER_PROPS","EDGE_ADD_METHODS","verb","generateKey","DEFAULTS","allowSelfLoops","addNode","NodeDataClass","unsafeAddNode","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","isSelfLoop","_undirectedSelfLoopCount","_directedSelfLoopCount","_undirectedSize","_directedSize","mergeEdge","asUpdater","alreadyExistingEdgeData","info","oldAttributes","sourceWasAdded","targetWasAdded","dropEdgeFromData","_EventEmitter","options","instancePrefix","edgeId","edgeKeyGenerator","availableEdgeKey","Map","prop","_options","_proto","_resetInstanceCounters","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","areDirectedNeighbors","areOutNeighbors","areInNeighbors","areUndirectedNeighbors","areNeighbors","areInboundNeighbors","areOutboundNeighbors","directedDegree","inboundDegree","degree","outboundDegree","inDegreeWithoutSelfLoops","outDegreeWithoutSelfLoops","directedDegreeWithoutSelfLoops","undirectedDegreeWithoutSelfLoops","inboundDegreeWithoutSelfLoops","loops","outboundDegreeWithoutSelfLoops","degreeWithoutSelfLoops","extremities","opposite","hasExtremity","isUndirected","isDirected","mergeNode","updateNode","dropNode","dropEdge","dropDirectedEdge","dropUndirectedEdge","clearEdges","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","updateAttributes","updateEachNodeAttributes","updateEachEdgeAttributes","forEachAdjacencyEntry","forEachAdjacencyEntryWithOrphans","forEachAssymetricAdjacencyEntry","forEachAssymetricAdjacencyEntryWithOrphans","nodes","forEachNode","findNode","mapNodes","order","someNode","everyNode","filterNodes","reduceNodes","nodeEntries","_export","_import","merge","_sa","_ta","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addUndirectedEdgeWithKey","addDirectedEdgeWithKey","_node","undirectedByDefault","_edge","_edge$undirected","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","nullCopy","emptyCopy","copy","toJSON","toString","inspect","multiIndex","label","tmp","desc","startsWith","dummy","EventEmitter","DirectedGraph","_Graph","finalOptions","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","instance"],"mappings":"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"}